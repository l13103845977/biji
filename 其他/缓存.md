存储类型：字符串、哈希、列表、集合、有序集合

对内，redis在存储对象时，会将对象进行封装（如，redisObject，sds等）后扔进内存

typedef struct redisObject {

　　unsigned type:4;    --- 存储类型

　　unsigned encoding:4;   --表示对象内部编码

　　unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */  --表示最后一次被访问的时间

　　int refcount;  --表示被访问的次数

　　void *ptr;  --指向具体的数据

} robj;



持久化 RDB和AOF **：前者将当前数据保存到硬盘，后者则是将每次执行的写命令保存到硬盘**

 开启aof 配置文件 appendonly yes

异常

   缓存穿透：缓存和数据中都没有的数据，这样每次请求都会查库，同时发生大量请求，给数据库造成巨大的查询压力。   

​    解决方法：当缓存和数据库都查不到时，可以将返回的空对象写到缓存中，下次请求直接走缓存。为了避免存储过多空对象，设置存活时间较短。

​         存在问题：如果有大量的key穿透，缓存空对象会占用宝贵的内存空间，key设置了过期时间，这时候数据库存在了该key的数据，造成数据不一致。

​    解决办法：布隆过滤器：根据预计插入个数和容错率算出位数组长度,hash取余判断是否存在

缓存击穿：一个key非常热门，失效同时会有大量请求请求数据库 

​      解决方法：设置为不失效率，   加互斥锁

​             存在问题： 数据不严格一致，

  缓存雪崩：也是key失效后请求数据库，大量key失效，巨大的请求量同时抵达数据库。

​    解决方法： 给不同的key设置不同的过期时间，让缓存失效时间尽量均匀

缓存预约：上线后，先将相关数据构建到缓存中。



 